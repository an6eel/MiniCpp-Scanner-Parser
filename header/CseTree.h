/**
 *  @file  CseTree.h
 *  @author  Ángel García Malagón
 *  @version 1.0
 *
 *  @brief Common Subexpression Elimination SyntaxTree
 *
 *  SyntaxTree of code, but with common subexpressions eliminated
 *
 **/


#ifndef __CSETREE_H__
#define __CSTREE_H__

#include "SyntaxTree.h"
#include <iostream>
#include <string>
#include <unordered_map>
#include <list>

/**
* \class CseTree
* @brief Delete common subexpressions in a SyntaxTree
*
**/

class CseTree: public SyntaxTree{
public:
  /**
    * @brief Construct a SyntaxTree
    * @param tokens List of tokens of code
    * @param vars List of variables of code
    * @param lines List of line of each token
    */

  CseTree(const TokenType *tokens, StringList::iterator vars,const int* lines);

  /** @brief Print the SyntaxTree with common subexpressions eliminated
	  */

  void print();

  /** @brief Print the code generated by CseTree
    * @param os Output stream where will be write the code
	  */

  void printCode(std::ostream& os);

  /** @brief Traverse the subtree node in preorder to get the expression
    * @param node subtree of expression
	  */

  std::string ExprToString(SyntaxTree::Node*& node) const;

  /**
    * @brief Apply CSE algorithm in SyntaxTree
    */

  void ApplyCSE();

private:
  int subexpr; //< Number of common subexpressions found
  std::unordered_map<std::string,SyntaxTree::Node*> cs_found; //< Hash Table with the common subexpressions found

  /**
    * @brief Find the node where Variables declaration starts
    * @return SyntaxTree::Node* Node where Variables declaration starts
    */

  SyntaxTree::Node* getDeclarations();

  /**
    * @brief Find the node where ASSIGN expressions starts
    * @return SyntaxTree::Node* Node where ASSIGN expressions starts
    */

  SyntaxTree::Node* getAssigns();

  /**
    * @brief Find the node with TokenType t
    * @param node Node where the search starts
    * @param t  Type of token searched
    * @return SyntaxTree::Node* Node with TokenType equal to t
    */

  SyntaxTree::Node* findType(SyntaxTree::Node*& node,TokenType t);

  /**
    * @brief Make a copy of a Node
    * @param n Node to copy
    * @return SyntaxTree::Node* Copy of node
    */

  SyntaxTree::Node* copyNode(SyntaxTree::Node*& n) const;

  /**
    * @brief Check if the node is a Operator
    * @param node Node checked
    * @retval True If node is a Operator
    * @retval False If node isn't a Operator
    */

  bool isOperator(SyntaxTree::Node*& node) const;

  /**
    * @brief Check if the node is a Binary Expresion (a Op b)
    * @param node Node checked
    * @retval True If node is a Binary Expression
    * @retval False If node isn't a Operator
    */

  bool BinaryExpr(SyntaxTree::Node*& node) const ;

  /**
    * @brief Check if n1 and n2 are the same Binary Expression
    * @param n1 Binary Expression
    * @param n2 Binary Expression
    * @retval True If n1 and n2 are the same Binary Expression
    * @retval False If n1 and n2 aren't the same Binary Expression
    */

  bool SameBExpr(SyntaxTree::Node*& n1,SyntaxTree::Node*& n2) const ;

  /**
    * @brief Check if root1 and root2 are the same tree
    * @param root1 subtree of SyntaxTree
    * @param root2 subtree of SyntaxTree
    * @retval True If root1 and root2 are the same tree
    * @retval False If root1 and root2 aren't the same tree
    */

  bool areIdentical(SyntaxTree::Node*& root1,SyntaxTree::Node*&  root2) const ;

  /**
    * @brief Check if S is a subtree of T
    * If S is a substree of T, that substree is a common subexpression, we eliminate it.
    * If mod isn't empty, that means that common subexpression already exists
    * @param T subtree of SyntaxTree
    * @param S subtree of SyntaxTree
    * @param mod Variable name of a common subexpression (S is a common subexpression of other expressions).
    * If is empty, that means that common subexpression doesn't exist
    * @retval True If S is a subtree of T
    * @retval False If S isn't a subtree of T
    */

  bool isSubtree(SyntaxTree::Node*& T,SyntaxTree::Node*& S,std::string mod="");

  /**
    * @brief Check if all possible subtrees of n1 are subtrees of tree
    * If any subtree of n1 is subtree of tree, that subtree is a common subexpression
    * @param n1 Expression
    * @param tree Expression
    */


  void find(SyntaxTree::Node*& n1,SyntaxTree::Node*& tree);



};

#endif
